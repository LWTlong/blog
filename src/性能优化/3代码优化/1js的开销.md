---
title: 代码中的优化
order: 1
#article: false
category:
  - 性能优化
tag:
  - 代码优化
---

## JS 在浏览器中的开销

js 在浏览器中，除了加载的耗时，下载完成后还有解析、编译的耗时，解析编译完成后最终才会进行执行。

![](images/image.png)

通过截图可以看见具体的一个耗时，并且能看见是哪个文件。

### 解决方案

* 代码拆分，按需加载。
* 避免主线程中有一些长任务，因为 js 的执行有时候是会造成堵塞的。


## v8

v8 是 google 开发的一个 js 引擎，在 node 中也是使用的 v8 引擎。

### v8 的优化

* 预解析：在执行之前，v8 会先解析 js 代码，解析完成之后，会生成一个抽象语法树（AST），然后生成字节码，最后再执行字节码。预解析可以减少解析和编译的时间。
* 预编译：在执行之前，v8 会先编译 js 代码，编译完成之后，会生成机器码，然后执行机器码。预编译可以减少编译的时间。

在编译过程中，v8 会进行一些优化，比如内联缓存、逃逸分析等。但是如果它发现这个优化其实不怎么样，它还会反优化，就是把已经优化的内容去掉，重新进行解析和编译。

## 对象优化

### 以相同的顺序创建对象

对象里，其实是有一个隐藏的属性，这个属性是对象的属性顺序，如果创建对象的属性顺序不同，那么这个隐藏的属性就会不同，那么 v8 在优化的时候，就会认为这个对象是不可优化的，就会重新进行解析和编译。

具体可以看本博客 javascript 里对象分类篇章里面的[对象的属性](http://www.anbc.cn/blog/JavaScript/2%E5%AF%B9%E8%B1%A1-Object/1%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7.html)。

在创建对象的时候，如果对象的属性是相同的顺序，那么 v8 解析的时候，有一个 `map` 的隐藏类，这里面就是记录一些可以复用的内容，比如说对象的属性配置等，如果对象的属性顺序变化了，v8 就不会复用这个 `map`，就会重新进行解析和编译。

```js
const obj1 = {
    name: 'lwt',
    age: 18
}
const obj2 = {
    name: 'wlp',
    age: 20
}
// 上面这段代码，这么创建 v8 是可以复用隐藏类的

const obj3 = {
    age: 18,
    name: 'lwt'
}
// 这个对象，v8 就无法复用上面的隐藏类，而是要重新解析和编译
```

### 避免对象额外增加属性

创建对象，最好一次性的创建好，避免去额外的增加属性。

因为，当创建的属性少于等于10个的时候，会保存在对象自身上，做为常规属性。当超过10个的时候，会保存在 `properties` 的隐藏属性上，并且当我们新增属性的时候，也会被存到 `properties` 上，它的访问速度会比访问自身常规属性和排序属性要慢一些，具体可以看[对象的属性](http://www.anbc.cn/blog/JavaScript/2%E5%AF%B9%E8%B1%A1-Object/1%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7.html)。

```js 
const obj = {
    name: 'lwt' // name 属性会当做对象内属性
}

obj.age = 18 // age 属性会被存在 properties store 上
```

### 避免直接操作类数组

类数组，比如 `arguments`，`NodeList` 等，要避免对这种类数组直接循环，v8 建议是哪怕你先转换为一个数组，再去循环，也比你直接循环一个类数组要高效。

### 避免创建稀疏数组

有空位元素的数组，就是稀疏数组。稀疏数组的访问会比较慢，一般情况下我们要避免创建稀疏数组。

## HTML 优化

### iframe

iframe 会阻塞主线程，所以我们要避免使用 iframe，如果需要使用 iframe，最好做延迟加载。

在使用 iframe 的时候，如果 iframe 一直没有加载完成，那么主线程就会被阻塞，父页面的 `onload` 事件也不会触发。

如果非要使用，可以做一个延迟加载

```html 
<iframe id="iframe" ></iframe>

<script>
// 延迟加载，在父页面内容完成后去加载
document.getElementById('iframe').setAttribute('src', 'https://anbc.cn/blog')
</script>
```

### 避免深层嵌套

避免深层嵌套，因为深层嵌套的元素，在渲染的时候，会先渲染父元素，然后再渲染子元素，如果嵌套太深，那么渲染的时间就会很长。

因为dom 树其实也是循环。

### 减少 HTML 文档大小

* 删除注释
* 压缩空白字符
* css & js 使用外链
* 删除元素默认属性


## CSS 优化

### 使用 will-change 属性

`will-change` 属性可以告诉浏览器，这个元素可能会发生改变，浏览器可以提前做一些优化。

在之前浏览器渲染原理里面说过，`will-change` 会告诉浏览器，这个元素需要单独分层出来。

### 使用 contain

`contain` 属性可以告诉浏览器，这个元素的内容不会影响到其他元素，在元素改变的时候，只需要计算当前元素的布局即可，不需要计算其他元素的布局。

